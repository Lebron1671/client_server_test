# Тестовое задание для компании ИНИТИ

## Постановка задачи

Существует условный сервер, на котором в оперативной памяти хранится очень длинная таблица (миллионы строк).
Строки отсортированы в некотором порядке, принцип сортировки может меняться, каждая строка имеет свой уникальный идентификатор.
Таблица живая, постоянно изменяется (несколько сотен/десятков изменений в секунду). В нее добавляются новые строки, обновляются и удаляются существующие.

Кроме этого, существует условный клиент, задача которого - отображение этой таблицы в реальном времени (все изменения видны сразу). При этом памяти на клиенте недостаточно для выгрузки всей таблицы.
Отображение осуществляется за счет того, что пользователю доступно окно высотой в N строк и в нём скроллер, позволяющий передвигаться по списку и сортировать ее по столбцам. При этом пользователь не ограничен в своих действиях - он может скроллироваться в любую часть списка и выбирать любой столбец для сортировки. Например, если на сервере список из миллиона записей и на клиенте скроллер передвинут на середину, то клиент должен отобразить N записей начиная с полумллионной.

Задача - придумать способ для хранения таблицы на сервере и протокол взаимодействия клиента и сервера для быстрого и корректного отображения данных клиентами. Важно, чтобы решение не предполагало использование сторонних продуктов (например, СУБД) или фреймворков. Следует использовать базовые контейнеры данных для выбранного для решения задачи языка (например, контейнеры стандартной библиотеки STL в случае реализации на C++ - map, vector, list или их аналоги в других языках).
В идеале - создать прототип на любом языке программирования, но вполне достаточно четко описать предполагаемую реализацию.

## Предложенное решение

1. Для хранения данных было решено выбрать Dictionary, так как словарь является хорошим выбором для ситуации, когда данные постоянно изменяются, так как получение, добавление, обновление и удаление элементов выполняется за постоянное время O(1), что позволяет поддерживать живую таблицу с миллионами строк сотнями/десятками изменений в секунду.
2. Для имитации работы сервера стоит создать класс "Server", в котором стоит добавить поле "data" для хранения данных, а также реализовать несколько методов:
    - "add_entry" для добавление новой записи в хранилище
    - "update_entry" для изменения записи в хранилище
    - "delete_entry" для удаления записи их хранилища
    - "get_entries" для получения списка строк
    - "sort_by_column" для сортировки данных по конкретному столбцу
3. Для имитации работы клиента стоит создать класс "Client", в котором стоит добавить поля "server" для хранения ссылки на объект класса "Server", "start_index" для хранения стартовой позиции строки, которая будет отображаться в окне, ну и "end_index" для хранения конечно позиции строки, которая будет отображаться в окне (в целом это размер окна), а также реализовать несколько методов:
    - "scroll" для скролла по странице вверх и в вниз
    - "sort_by_column" для вызова метода сортировки данных по конкретному столбцу
    - "display" для получения данных с сервера и отображения их на странице
    - "discard" для сброса сортировки по выбранному столбцу и возврату к сортировке по "id", а также сброс сколллинга
    - "change_page_size" для изменения размера окна
    - "pagination" для перехода на следующую или предыдующую страницу
    - "add_person" для добавление новой записи в хранилище
    - "update_person" для изменения записи в хранилище
    - "delete_person" для удаления записи их хранилища


## Тест производительности
1. Для теста был создан метод для генерации определенного кол-ва данных
2. При добавлении данных в словарь структура данных выглядит следующим образом: "{1: {'Name': 'Nick', 'Age': 27'}}"
3. При получении данных они преобразуются в объект Person с полями id, name и age
4. Основные шаги теста:
   - Первоначальное отображение первых 10 записей
   - Скроллинг вниз на одну позициюю
   - Скроллинг вверх на одну позицию
   - Установка сортировку по возрастанию по столбцу 'Age'
   - Установка сортировку по убыванию по столбцу 'Name'
   - Изменение размера окна с 10 на 50
   - Изменение размера окна с 50 на 100
   - Пагинация на следующую страницу
   - Пагинация на предыдущую страницу
   - Сброс настроек
5. Конфигируация:
   - MacBook Air (M2, 2022)
   - Memory 8Gb
6. Результаты:
   - Для 1.000.000 записей время выполнения = 1.800498 секунд 
   - Для 5.000.000 записей время выполнения = 10.253641 секунд 
   - Для 10.000.000 записей время выполнения = 34.524542 секунд