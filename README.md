# Тестовое задание для компании ИНИТИ

## Постановка задачи

Существует условный сервер, на котором в оперативной памяти хранится очень длинная таблица (миллионы строк).
Строки отсортированы в некотором порядке, принцип сортировки может меняться, каждая строка имеет свой уникальный идентификатор.
Таблица живая, постоянно изменяется (несколько сотен/десятков изменений в секунду). В нее добавляются новые строки, обновляются и удаляются существующие.

Кроме этого, существует условный клиент, задача которого - отображение этой таблицы в реальном времени (все изменения видны сразу). При этом памяти на клиенте недостаточно для выгрузки всей таблицы.
Отображение осуществляется за счет того, что пользователю доступно окно высотой в N строк и в нём скроллер, позволяющий передвигаться по списку и сортировать ее по столбцам. При этом пользователь не ограничен в своих действиях - он может скроллироваться в любую часть списка и выбирать любой столбец для сортировки. Например, если на сервере список из миллиона записей и на клиенте скроллер передвинут на середину, то клиент должен отобразить N записей начиная с полумллионной.

Задача - придумать способ для хранения таблицы на сервере и протокол взаимодействия клиента и сервера для быстрого и корректного отображения данных клиентами. Важно, чтобы решение не предполагало использование сторонних продуктов (например, СУБД) или фреймворков. Следует использовать базовые контейнеры данных для выбранного для решения задачи языка (например, контейнеры стандартной библиотеки STL в случае реализации на C++ - map, vector, list или их аналоги в других языках).
В идеале - создать прототип на любом языке программирования, но вполне достаточно четко описать предполагаемую реализацию.

## Предложенное решение

1. Для хранения данных было решено выбрать AVL-дерево (сбалансированное бинарное дерево поиска), из-за эффективного сохранения упорядоченности, предсказуемой производительности (все операции выполняются за O(log n) и балансировки данных
2. Для имитации работы сервера стоит создать класс "Server", в котором стоит добавить поле "data" для хранения данных, а также реализовать несколько методов:
    - "insert" для добавление новой записи в хранилище
    - "update" для изменения записи в хранилище
    - "delete" для удаления записи из хранилища
    - "get_batch_entries" для получения среза данных для отображения у клиента
    - "sort" для сортировки данных по конкретному столбцу
    - "get_new_id" для генерации следующего id
    - "subscribe" для добавления нового клиента в список наблюдателей
    - "notify_observers" для оповещения клиентов о том что данные были модифицированы
    - "_insert_recursive", "_update_recursive", "_delete_recursive", "_in_order_traversal_recursive" для рекурсивного обхода дерева и выполения соответствующих операций с данными
    - "_rotate_left", "_rotate_right", "_get_balance" для выполнения балансировки дерева
    - "_get_height" для получения высоты узла дерева
    - "_get_min_value_node" для поиска узла с минимальным значением в заданном поддереве. Используется в процессе удаления узла
3. Для имитации работы клиента стоит создать класс "Client", в котором стоит добавить поля "server" для хранения ссылки на объект класса "Server", "start_index" для хранения стартовой позиции строки, которая будет отображаться в окне, ну и "end_index" для хранения конечно позиции строки, которая будет отображаться в окне (в целом это размер окна), а также реализовать несколько методов:
    - "scroll" для скролла по странице вверх и в вниз
    - "sort" для вызова метода сортировки данных по конкретному столбцу
    - "display" для получения данных с сервера и отображения их на странице
    - "discard" для сброса сортировки по выбранному столбцу и возврату к сортировке по "id", а также сброс сколллинга
    - "change_page_size" для изменения размера окна
    - "paginate" для перехода на следующую или предыдующую страницу
    - "add_person" для добавление новой записи в хранилище
    - "update_person" для изменения записи в хранилище
    - "delete_person" для удаления записи их хранилища


## Тест производительности
1. Для теста был создан метод для генерации определенного кол-ва данных
2. При добавлении данных в дерево структура данных выглядит следующим образом: "Person(id, name, age)", например, "Person(1, 'Nick',27)"
3. Основные шаги теста:
   - Первоначальное отображение первых 10 записей
   - Скроллинг вниз на одну позициюю
   - Скроллинг вверх на одну позицию
   - Установка сортировку по возрастанию по столбцу 'Age'
   - Установка сортировку по убыванию по столбцу 'Name'
   - Изменение размера окна с 10 на 50
   - Изменение размера окна с 50 на 100
   - Пагинация на следующую страницу
   - Пагинация на предыдущую страницу
   - Сброс настроек
4. Конфигируация:
   - MacBook Air (M2, 2022)
   - Memory 8Gb
5. Результаты:
   - Для 1.000.000 записей время выполнения = 0.845760 секунд
   - Для 5.000.000 записей время выполнения = 4.330996 секунд
   - Для 10.000.000 записей время выполнения = 12.270894 секунд 